// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IStrategy.sol";

/**
* @title SimpleYieldStrategy
* @dev A basic yield farming strategy that interacts with a mock yield protocol
*/
contract SimpleYieldStrategy is IStrategy {
    address public owner;
    address public targetProtocol;
    uint256 public totalDeposited;
    uint256 public lastExecutionTime;
    uint256 public riskFactor; // 1-100, where 1 is lowest risk and 100 is highest
    string public name;
    
    // Performance metrics
    uint256 public totalReturns;
    uint256 public executionCount;
    
    event Deposit(uint256 amount);
    event Withdraw(uint256 amount);
    event ReturnsHarvested(uint256 amount);
    event RiskFactorUpdated(uint256 newRiskFactor);
    
    /**
    * @dev Constructor to initialize the strategy with name, target protocol address, risk factor, and owner
    * @param _name Name of the strategy
    * @param _targetProtocol Address of the yield protocol to interact with
    * @param _riskFactor Initial risk factor (1-100)
    * @param _owner Address of the strategy owner
    */
    constructor(string memory _name, address _targetProtocol, uint8 _riskFactor, address _owner) {
        require(_targetProtocol != address(0), "Invalid protocol address");
        require(_riskFactor > 0 && _riskFactor <= 100, "Risk factor must be between 1-100");
        require(_owner != address(0), "Invalid owner address");
        
        name = _name;
        owner = _owner;
        targetProtocol = _targetProtocol;
        riskFactor = _riskFactor;
        lastExecutionTime = block.timestamp;
    }
    
    /**
    * @dev Modifier to restrict function access to owner only
    */
    modifier onlyOwner() {
        require(msg.sender == owner, "Caller is not the owner");
        _;
    }
    
    /**
    * @dev Execute the yield farming strategy
    * @param data Encoded parameters for the strategy execution
    * @return profit Amount of yield/profit generated from this execution
    */
    function execute(bytes calldata data) external override returns (uint256 profit) {
        // Decode the execution parameters
        (uint256 amount, bool isDeposit) = abi.decode(data, (uint256, bool));
        
        if (isDeposit) {
            // Mock deposit to target protocol
            totalDeposited += amount;
            emit Deposit(amount);
        } else {
            // Mock withdrawal from target protocol
            require(amount <= totalDeposited, "Insufficient funds");
            totalDeposited -= amount;
            emit Withdraw(amount);
        }
        
        // Calculate simulated yield based on time passed, risk factor and amount deposited
        uint256 timePassed = block.timestamp - lastExecutionTime;
        profit = calculateYield(timePassed);

        // Update performance metrics
        totalReturns += profit;
        executionCount++;
        lastExecutionTime = block.timestamp;

        emit ReturnsHarvested(profit);

        return profit;
    }
    
    /**
    * @dev Calculate yield based on time passed, risk factor and deposited amount
    * @param timePassed Time passed since last execution in seconds
    * @return yield Amount of yield generated
    */
    function calculateYield(uint256 timePassed) internal view returns (uint256) {
        // Mock yield calculation:
        // Higher risk = potentially higher returns
        // (totalDeposited * timePassed * riskFactor) / (365 days * 100)
        // This simulates annual percentage yield between 0-riskFactor%
        if (totalDeposited == 0) return 0;
        
        return (totalDeposited * timePassed * riskFactor) / (365 days * 100);
    }
    
    /**
    * @dev Get the performance metrics of this strategy
    * @return annualizedReturn Annual percentage yield (APY)
    * @return totalProfit Total profit/returns generated by the strategy
    * @return executionCountResult Number of times the strategy has been executed
    * @return successRate Percentage of successful executions
    * @return riskScore Risk factor score of the strategy (1-100)
    */
    function getPerformanceMetrics() external view override returns (uint256 annualizedReturn, uint256 totalProfit, uint256 executionCountResult, uint256 successRate, uint8 riskScore) {
        // Calculate annualized return (APY)
        annualizedReturn = totalDeposited > 0 ? (totalReturns * 365 days * 100) / (totalDeposited * (block.timestamp - lastExecutionTime)) : 0;
        
        // Set the return values
        totalProfit = totalReturns;
        executionCountResult = executionCount;
        successRate = 100; // Assuming 100% success rate
        riskScore = uint8(riskFactor);
        
        return (annualizedReturn, totalProfit, executionCountResult, successRate, riskScore);
    }
    
    /**
    * @dev Get a description of this strategy
    * @return strategyName Name of the strategy
    * @return description Human-readable description of the strategy
    * @return version Version number of the strategy
    */
    function getDescription() external view override returns (string memory strategyName, string memory description, string memory version) {
        return (
            name,
            "A basic yield farming strategy that interacts with a mock yield protocol",
            "1.0.0"
        );
    }
    
    /**
    * @dev Update the risk factor of the strategy
    * @param _newRiskFactor New risk factor (1-100)
    */
    function updateRiskFactor(uint256 _newRiskFactor) external onlyOwner {
        require(_newRiskFactor > 0 && _newRiskFactor <= 100, "Risk factor must be between 1-100");
        riskFactor = _newRiskFactor;
        emit RiskFactorUpdated(_newRiskFactor);
    }
    
    /**
    * @dev Change the target protocol
    * @param _newProtocol Address of the new protocol
    */
    function updateTargetProtocol(address _newProtocol) external onlyOwner {
        require(_newProtocol != address(0), "Invalid protocol address");
        targetProtocol = _newProtocol;
    }
    
    /**
    * @dev Transfer ownership of the strategy
    * @param _newOwner Address of the new owner
    */
    function transferOwnership(address _newOwner) external onlyOwner {
        require(_newOwner != address(0), "Invalid owner address");
        owner = _newOwner;
    }
}

